import Mathlib

open Classical

variable {K R Γ₀} [Ring R] [DivisionRing K] [LinearOrderedCommMonoidWithZero Γ₀]

noncomputable section
#synth LinearOrder Unit
#synth CommMonoid Unit
-- #synth LinearOrderedCommMonoid Unit

instance : LinearOrderedCommMonoid Unit where
  mul_le_mul_left _ _ _ := le_refl
  le_total _ _ := Or.inl (le_refl _)
  decidableLE := Classical.decRel _
  decidableEq := Classical.decRel _
  decidableLT := Classical.decRel _
  -- min_def := _
  -- max_def := _
  compare_eq_compareOfLessAndEq _ _:= by
    simp only [compare, compareOfLessAndEq, ite_true,
      ite_false, lt_self_iff_false]

#synth LinearOrderedCommMonoidWithZero (WithZero Unit)
#eval (0 : WithZero Unit) = 1

namespace Valuation

section trivial

/-
Note: For full generality, any nontrivial ring can define a trivial valuation:
v (x) = 0 if x is zero-divisor (in the bi-ideal generated by all left/right-zero-divisors in non-commutative case), v (x) = 1 otherwise.
-/
-- should be no zero divisor here
def TrivialValuation  : Valuation R (WithZero Unit) where
  toFun x := if x = 0 then 0 else 1
  map_zero' := by simp only [ite_true]
  map_one' := by simp only [one_ne_zero, ite_false]
  map_mul' x y:= by simp only [mul_eq_zero, mul_ite, mul_zero, mul_one]; sorry
  map_add_le_max' := sorry -- should be a theorem

def IsTrivial (v : Valuation K Γ₀) : Prop := IsEquiv v TrivialValuation

/- What implies trivial and trivial implies what-/

end trivial

section discrete

-- def IsEquivToDiscrete :=

/- What implies discrete and discrete implies what-/

end discrete

end Valuation
